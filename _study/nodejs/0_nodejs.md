---
title: "Node.js란"
permalink: /study/nodejs/0/
comments: true
categories: []
toc: true
---

**Reference**

- 실무 환경에 맞춘 Node.js 프로그래밍
  - 조인석, 황수빈 지음
<br><br>

---

# `JavaScript`

- 웹 브라우저에서 실행되는 스크립트 언어

- `HTML`로 작성된 웹 페이지에 함수 형태로 작성되는 언어

- 해석형 언어
  - 컴파일할 필요 없이 소스 코드 자체가 실행 시에 인터프리터에 의해 해석되어지는 언어

- 데이터 타입에 크게 민감하지 않음 (Weak Typing)
  - ex. 숫자 2와 문자 2를 서로 붙이거나 더할 수 있음
<br><br>

---

# `V8`

- 구글에 의해 `C++`로 개발된 오픈 소스 자바스크립트 엔진

- 기존의 컴파일된 바이트코드를 실행하거나 인터프리터로 해석하는 대신, 자바스트립트를 컴파일하여 네이티브 머신 코드로 변경 후 실행할 수 있게 해줌
  - 이렇게 컴파일된 코드는 코드의 실행 프로파일을 분석하여, 실행 시에 다시 한 번 최적화함

- 객체에 할당되는 메모리를 효율적으로 관리하며, 더 이상 필요 없는 객체는 수집하여 버림 (Garbage Collection)

- `V8` 엔진은 웹 브라우저(크롬)에서 실행될 뿐 아니라 독립형의 고성능 엔진으로 사용할 수 있음
  - 웹 브라우저와 전혀 상관없이 사용 가능
  - `V8` 엔진을 탑재하여 독립형 자바스크립트 언어로 개발을 가능하게 한 플랫폼이 **`Node.js`**
<br><br>

---

# `Node.js`

- `V8`을 이용하여 `JavaScript`의 강력함과 단순함을 활용한 이벤트 기반의 논블록킹 I/O를 주 컨셉으로 만든 백엔드(Back-end) `JavaScript` 기반 플랫폼
  - `V8` 기반으로 만들어져 빠르고 확장 가능한 네트워크 프로그램 쉽게 작성 가능
  - 이벤트 주도(Event-driven), 논블록킹(Non-blocking) I/O 모델을 사용하므로 분산 환경에서 실행되는 가장 가볍고 효과적인, 완벽한 데이터 집중적(Data-intensive)인 실시간 어플리케이션 작성 가능

- 대량의 데이터를 조회하고 CPU의 사용을 요구하면서 다소 긴 처리 시간을 요구하는 웹 어플리케이션은 `Node.js`가 좋은 선택이 아님
  - `Node.js`는 광활한 네트워크 환경에서 클라이언트가 원하는 데이터를 밀어 넣고 최대한 빨리 응답을 받기 위해 설계됨

**참고** <br>
대형 할인 매장에서 물건을 모두 선택 후, 계산을 위해 계산대 앞에 줄을 선다. 계산하는 점원이 1명 밖에 없고, 3명의 손님이 차례를 기다리고 있다고 가정하자. 3명의 손님이 모두 계산할 때까지 기다려야 한다. 이것을 **블록킹**(Blocking)이라고 한다. <br>
실제로 데이터를 처리하는 순간 이외에 블록킹되는 시간동안 자원은 할당되어 있으나 실질적으로는 사용하지 않는 비효율적인 부분이 생긴다. <br><br>
다른 예를 하나 생각해보자. 카페 카운터에서 커피를 주문하고 무선 호출기를 받았다고 가정하자. 호출기를 받고 자리에 앉아 하고 싶은 일을 한다. 주문한 커피가 다 준비되어 호출기가 울리면, 카운터로 가서 주문했던 커피를 받아 다시 자리 앉는다. 커피를 주문한 다음 준비될 때까지 전혀 간섭을 받지 않고 하고 싶은 일을 수행했다. 즉, **블록킹 당하지 않았다**(Non-blocking). <br><br>
카운터 종업원은 [주문자가 커피를 주문했다]는 이벤트, [커피 준비가 완료되었다]는 두가지 이벤트를 받았다. 종업원은 해당 이벤트가 발생했을 때 본인이 해야 할 일을 했다. 이것이 **이벤트 주도**이다. 여기서 호출기는 [커피 준비가 완료되었다]고 알려줬다. 이를 **이벤트 콜백**(Event Callback)이라고 한다.
{: .notice--success}


- `Node.js` 아케텍쳐 <br><br>
  ![fig.1](../images/0-1.png)
<br><br>

---

# Node REPL

- Node REPL(Read-Evaluate-Print-Loop) 실행 화면 <br><br>
![fig.1](../images/0-2.png)

- `Node.js`는 `Perl`, `Python`, `Ruby` 등과 같이 그 자체가 서버이며 실행 환경을 제공하고 있음
- Node REPL을 통해 작성한 `JavaScript` 코드는 직접 돌려보며 테스트 수행 가능
- Node REPL은 `Node.js`를 이해하는 데 훌륭한 개발 환경 제공
- 가장 선호하는 텍스트 에디터와 연결하여 코딩 및 실행 환경 구축 가능
- Node REPL의 모든 명령어는 `.`으로 시작함
  - `.beak` : 현재 구동 중인 작업을 종료하고 대기 상태로 변경
  - `.clear` : 현재 context 초기화, `Node.js`를 재실행하지 않더라도 사용 중이었던 모든 변수 및 클로져 등을 깨끗이 정리해줌
  - `.exit` : Node REPL 종료
  - `.help` : 도움말 메뉴 출력
  - `.load` : js 파일을 REPL 세션으로 적재
  - `.save` : 현재 수행 중인 REPL 세션에서 실행하였던 모든 명령어들을 파일로 저장
<br><br>

---

# NPM

- `Node.js`의 큰 장점 중 하나는 기능을 확장한 수많은 모듈들이 존재하고, 쉽게 다운로드 및 설치 가능
  - 모듈 설치를 위해 NPM(Node Package Manager)의 이해 및 활용 필요
- NPM은 `Node.js`의 자바스크립트 플랫폼 관리를 위한 주체
  - 모듈의 의존성 충돌 관련 문제를 깔끔하게 해결해줌
- NPM은 크게 세 가지 기능을 함
  - 서드파티 패키지 중앙 저장소
  - 설치된 패키지 관리 수단
  - 다른 패키지에 있는 의존성을 정의하는 표준
- `npm`으로 설치한 모든 모듈은 `package.json` 파일에 타 모듈과의 의존성 및 설치를 위한 정보들이 기술되어 있음
<br><br>

**모듈 설치 방법**

- `Node.js`가 설치된 경로로 이동 후, `npm` 사용
  - `Node.js`가 설치된 경로의 파일 목록들 <br><br>
    ![fig.1](../images/0-3.png)
  - `npm` 명령어 사용

    npm install {module_name}
    {: .notice--info}

**예시**

```
$ npm install express
```


**참고** <br>
<`Node.js` 모듈의 로컬 설치와 글로벌 설치> <br>
위의 방식은 로컬 설치 방식으로, 설치하고자 하는 위치에서만 설치가 가능하다.
만약 어떤 사용자다 어떤 위치에서도 사용 가능하게 설치하고 싶다면 글로벌 설치 방식을 선책해야 한다.
방법은 간단하다. `-g` 플래그를 추가하면 된다. <br><br>
{: .notice--success}

```
$ npm install -g express
```
